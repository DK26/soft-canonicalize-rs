#![cfg(windows)]
//! Archive-style Path Pattern Tests
//!
//! This suite tests path canonicalization when handling ADS-like patterns that
//! commonly originate from compressed archives like ZIP or TAR files.
//! We test the paths directly without needing actual archive dependencies.

use soft_canonicalize::soft_canonicalize;
use std::io::{self, ErrorKind};

fn expect_invalid(res: io::Result<impl std::fmt::Debug>, pattern: &str) {
    match res {
        Ok(v) => panic!("Expected InvalidInput for pattern '{pattern}', got Ok({v:?})"),
        Err(e) => assert_eq!(
            e.kind(),
            ErrorKind::InvalidInput,
            "Expected InvalidInput for pattern '{pattern}', got {e:?}"
        ),
    }
}

#[test]
fn test_archive_style_ads_patterns() -> io::Result<()> {
    // Test patterns commonly found in malicious archive entries
    let malicious_patterns = [
        "file.txt:stream..\\..\\evil.exe",
        "document.pdf:Zone.Identifier:..\\sensitive.txt",
        "image.jpg:Alternate:..\\..\\system32\\backdoor.dll",
        "archive.rar:hidden..\\..\\..\\etc\\passwd",
        "backup.tar:metadata:..\\windows\\system32\\cmd.exe",
    ];

    for pattern in malicious_patterns {
        expect_invalid(soft_canonicalize(pattern), pattern);
    }

    Ok(())
}

#[test]
fn test_tar_style_ads_patterns() -> io::Result<()> {
    // Test malicious ADS patterns that could come from TAR archives
    let malicious_ads_path = "file.txt:stream..\\..\\evil.exe";
    expect_invalid(soft_canonicalize(malicious_ads_path), malicious_ads_path);

    // Additional TAR-style patterns
    let tar_patterns = [
        "backup.tar.gz:metadata:..\\sensitive.conf",
        "archive.tgz:extended_attrs:..\\..\\root\\secret",
        "bundle.tar.xz:link_target:..\\system\\important.dll",
    ];

    for pattern in tar_patterns {
        expect_invalid(soft_canonicalize(pattern), pattern);
    }

    Ok(())
}

#[test]
fn test_archive_bomb_style_ads() -> io::Result<()> {
    // Test extremely long ADS names (archive bomb style) with traversal
    let long_name = "a".repeat(1024);
    let malicious_name = format!("file.txt:{long_name}:..\\..\\evil.exe");

    expect_invalid(soft_canonicalize(&malicious_name), &malicious_name);

    // Test nested long patterns
    let nested_long = format!("dir\\subdir\\{long_name}:stream:..\\..\\..\\escape.exe");
    expect_invalid(soft_canonicalize(&nested_long), &nested_long);

    Ok(())
}
